// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for BatchResultItemStatus.
const (
	BatchResultItemStatusError BatchResultItemStatus = "error"
	BatchResultItemStatusOk    BatchResultItemStatus = "ok"
)

// Defines values for CollectionType.
const (
	CollectionTypeGeo  CollectionType = "geo"
	CollectionTypeText CollectionType = "text"
)

// Defines values for CreateCollectionRequestType.
const (
	CreateCollectionRequestTypeGeo  CreateCollectionRequestType = "geo"
	CreateCollectionRequestTypeText CreateCollectionRequestType = "text"
)

// Defines values for ErrorResponseCode.
const (
	ErrorResponseCodeBadRequest                ErrorResponseCode = "bad_request"
	ErrorResponseCodeCollectionAlreadyExists   ErrorResponseCode = "collection_already_exists"
	ErrorResponseCodeCollectionNotFound        ErrorResponseCode = "collection_not_found"
	ErrorResponseCodeCollectionTypeMismatch    ErrorResponseCode = "collection_type_mismatch"
	ErrorResponseCodeDocumentNotFound          ErrorResponseCode = "document_not_found"
	ErrorResponseCodeEmbeddingProviderError    ErrorResponseCode = "embedding_provider_error"
	ErrorResponseCodeEmbeddingQuotaExceeded    ErrorResponseCode = "embedding_quota_exceeded"
	ErrorResponseCodeGeoQueryInvalid           ErrorResponseCode = "geo_query_invalid"
	ErrorResponseCodeInternalError             ErrorResponseCode = "internal_error"
	ErrorResponseCodeKeywordSearchNotSupported ErrorResponseCode = "keyword_search_not_supported"
	ErrorResponseCodeNotImplemented            ErrorResponseCode = "not_implemented"
	ErrorResponseCodeRateLimited               ErrorResponseCode = "rate_limited"
	ErrorResponseCodeRevisionConflict          ErrorResponseCode = "revision_conflict"
	ErrorResponseCodeValidationFailed          ErrorResponseCode = "validation_failed"
	ErrorResponseCodeVectorDimMismatch         ErrorResponseCode = "vector_dim_mismatch"
)

// Defines values for FieldDefinitionType.
const (
	Numeric FieldDefinitionType = "numeric"
	Tag     FieldDefinitionType = "tag"
)

// Defines values for HealthResponseChecks.
const (
	HealthResponseChecksError HealthResponseChecks = "error"
	HealthResponseChecksOk    HealthResponseChecks = "ok"
)

// Defines values for HealthResponseStatus.
const (
	Degraded HealthResponseStatus = "degraded"
	Error    HealthResponseStatus = "error"
	Ok       HealthResponseStatus = "ok"
)

// Defines values for SearchRequestMode.
const (
	Geo      SearchRequestMode = "geo"
	Hybrid   SearchRequestMode = "hybrid"
	Keyword  SearchRequestMode = "keyword"
	Semantic SearchRequestMode = "semantic"
)

// Defines values for UsageResponsePeriod.
const (
	UsageResponsePeriodDay   UsageResponsePeriod = "day"
	UsageResponsePeriodMonth UsageResponsePeriod = "month"
	UsageResponsePeriodTotal UsageResponsePeriod = "total"
)

// Defines values for GetUsageParamsPeriod.
const (
	GetUsageParamsPeriodDay   GetUsageParamsPeriod = "day"
	GetUsageParamsPeriodMonth GetUsageParamsPeriod = "month"
	GetUsageParamsPeriodTotal GetUsageParamsPeriod = "total"
)

// BatchDeleteRequest defines model for BatchDeleteRequest.
type BatchDeleteRequest struct {
	Ids []string `json:"ids"`
}

// BatchDeleteResponse defines model for BatchDeleteResponse.
type BatchDeleteResponse struct {
	// Failed Number of failed items
	Failed int               `json:"failed"`
	Items  []BatchResultItem `json:"items"`

	// Succeeded Number of successfully deleted items
	Succeeded int `json:"succeeded"`
}

// BatchResultItem defines model for BatchResultItem.
type BatchResultItem struct {
	Error  *ErrorResponse        `json:"error,omitempty"`
	Id     string                `json:"id"`
	Status BatchResultItemStatus `json:"status"`
}

// BatchResultItemStatus defines model for BatchResultItem.Status.
type BatchResultItemStatus string

// BatchUpsertItem defines model for BatchUpsertItem.
type BatchUpsertItem struct {
	// Content Document text content
	Content string `json:"content"`

	// Id Document ID
	Id       string              `json:"id"`
	Numerics *map[string]float32 `json:"numerics,omitempty"`
	Tags     *map[string]string  `json:"tags,omitempty"`
}

// BatchUpsertRequest defines model for BatchUpsertRequest.
type BatchUpsertRequest struct {
	Documents []BatchUpsertItem `json:"documents"`
}

// BatchUpsertResponse defines model for BatchUpsertResponse.
type BatchUpsertResponse struct {
	// Failed Number of failed items
	Failed int               `json:"failed"`
	Items  []BatchResultItem `json:"items"`

	// Succeeded Number of successfully processed items
	Succeeded int `json:"succeeded"`
}

// BudgetStatus defines model for BudgetStatus.
type BudgetStatus struct {
	// IsExhausted Whether the budget is exhausted (tokens_remaining = 0)
	IsExhausted bool `json:"is_exhausted"`

	// ResetsAt When the budget resets (ISO 8601, UTC). Absent if unlimited.
	ResetsAt *time.Time `json:"resets_at,omitempty"`

	// TokensLimit Token budget for the current period. -1 means unlimited.
	TokensLimit int `json:"tokens_limit"`

	// TokensRemaining Tokens remaining in the current period. -1 if unlimited.
	TokensRemaining int `json:"tokens_remaining"`
}

// Collection defines model for Collection.
type Collection struct {
	// CreatedAt Collection creation time (ISO 8601, UTC)
	CreatedAt time.Time `json:"created_at"`

	// DocumentCount Approximate number of documents. May lag behind recent
	// batch operations by a few seconds.
	DocumentCount *int `json:"document_count,omitempty"`

	// Fields Indexed fields for filtering (empty if search-only)
	Fields *[]FieldDefinition `json:"fields,omitempty"`
	Name   string             `json:"name"`

	// Revision Monotonically increasing revision number. Incremented on any
	// mutation (field schema changes, etc). Starts at 1.
	Revision int `json:"revision"`

	// Type Collection type (text or geo)
	Type *CollectionType `json:"type,omitempty"`

	// VectorDimensions Vector dimensions (set automatically by the platform)
	VectorDimensions *int `json:"vector_dimensions,omitempty"`
}

// CollectionType Collection type (text or geo)
type CollectionType string

// CollectionCursorListResponse defines model for CollectionCursorListResponse.
type CollectionCursorListResponse struct {
	// HasMore Whether more results are available
	HasMore bool         `json:"has_more"`
	Items   []Collection `json:"items"`

	// NextCursor Opaque pagination token for the next page. Absent when has_more is false.
	// Clients must treat this value as an opaque string — do not parse, decode,
	// or construct cursor values. The format may change without notice.
	NextCursor *string `json:"next_cursor,omitempty"`
}

// CreateCollectionRequest defines model for CreateCollectionRequest.
type CreateCollectionRequest struct {
	// Fields Optional fields for filtering (max 64).
	// If omitted, only vector/keyword search is available.
	Fields *[]FieldDefinition `json:"fields,omitempty"`

	// Name Collection name (alphanumeric, underscores, hyphens)
	Name string `json:"name"`

	// Type Collection type:
	// - **text** (default): embedding-based vector search. Documents have
	//   `content` that is automatically vectorized. Supports hybrid,
	//   semantic, and keyword search modes.
	// - **geo**: geographic proximity search. Documents have `latitude`
	//   and `longitude` numeric fields. Content is optional. Coordinates
	//   are converted to ECEF vectors for KNN search. Only `geo` search
	//   mode is supported.
	Type *CreateCollectionRequestType `json:"type,omitempty"`
}

// CreateCollectionRequestType Collection type:
//   - **text** (default): embedding-based vector search. Documents have
//     `content` that is automatically vectorized. Supports hybrid,
//     semantic, and keyword search modes.
//   - **geo**: geographic proximity search. Documents have `latitude`
//     and `longitude` numeric fields. Content is optional. Coordinates
//     are converted to ECEF vectors for KNN search. Only `geo` search
//     mode is supported.
type CreateCollectionRequestType string

// DocumentCursorListResponse defines model for DocumentCursorListResponse.
type DocumentCursorListResponse struct {
	// HasMore Whether more results are available
	HasMore bool               `json:"has_more"`
	Items   []DocumentResponse `json:"items"`

	// NextCursor Opaque pagination token for the next page. Absent when has_more is false.
	// Clients must treat this value as an opaque string — do not parse, decode,
	// or construct cursor values. The format may change without notice.
	NextCursor *string `json:"next_cursor,omitempty"`
}

// DocumentResponse defines model for DocumentResponse.
type DocumentResponse struct {
	Content  string              `json:"content"`
	Id       string              `json:"id"`
	Numerics *map[string]float32 `json:"numerics,omitempty"`

	// Revision Monotonically increasing revision number. Use with `If-Match`
	// header on PUT/PATCH to prevent lost updates. Starts at 1.
	Revision int                `json:"revision"`
	Tags     *map[string]string `json:"tags,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Code Machine-readable error code
	Code ErrorResponseCode `json:"code"`

	// Details Field-level validation errors
	Details *[]ValidationError `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// ErrorResponseCode Machine-readable error code
type ErrorResponseCode string

// FieldDefinition defines model for FieldDefinition.
type FieldDefinition struct {
	// Name Field name in JSON document. Must not conflict with reserved
	// names: `id`, `content`, `score`, `vector`.
	Name string `json:"name"`

	// Type Field type for indexing:
	// - tag: categorical/string filtering (exact match via `match`)
	// - numeric: numeric range filtering (via `range` with gt/gte/lt/lte)
	// Document values for tag fields are passed in the `tags` object
	// of the document body.
	Type FieldDefinitionType `json:"type"`
}

// FieldDefinitionType Field type for indexing:
// - tag: categorical/string filtering (exact match via `match`)
// - numeric: numeric range filtering (via `range` with gt/gte/lt/lte)
// Document values for tag fields are passed in the `tags` object
// of the document body.
type FieldDefinitionType string

// FilterCondition A single filter condition. Exactly one of `match` or `range`
// must be provided. Use `match` for tag fields (exact string value),
// `range` for numeric fields. Providing both returns 400. Providing
// neither returns 400.
type FilterCondition struct {
	// Key Field name (must exist in collection schema)
	Key string `json:"key"`

	// Match Exact string match for tag fields. For boolean-like values,
	// use string literals: `"true"`, `"false"`.
	Match *string `json:"match,omitempty"`

	// Range Numeric range filter. At least one boundary must be specified.
	// Multiple boundaries are combined with AND. Do not mix `gt` with
	// `gte` or `lt` with `lte` — returns 400 if both provided for
	// the same direction.
	Range *RangeFilter `json:"range,omitempty"`
}

// FilterExpression Flat filter with `must`, `should`, `must_not` semantics.
// One level only — no recursive nesting.
//
// - **must**: all conditions must match (AND).
// - **should**: at least one condition must match (OR).
// - **must_not**: none of the conditions may match (NOT).
//
// Each condition targets a field by `key` and uses either `match`
// (exact value, for tag fields) or `range` (for numeric fields).
//
// Equivalent boolean query semantics:
// ```
// language=python AND NOT archived=true AND (repo=vecdex OR repo=redcat)
// ```
//
// An empty filter (`{}`) or a filter with all empty arrays is a no-op —
// no filtering is applied, all candidates are returned.
//
// **Error handling:** Invalid filter expressions return 400 with
// `code: validation_failed`. The `details` array contains per-field
// errors, e.g. `{"field": "filters.must[0].key", "message": "unknown field"}`.
// Unknown field names (not in collection schema) also return 400.
type FilterExpression struct {
	// Must All conditions must match (AND)
	Must *[]FilterCondition `json:"must,omitempty"`

	// MustNot None of the conditions may match (NOT)
	MustNot *[]FilterCondition `json:"must_not,omitempty"`

	// Should At least one condition must match (OR)
	Should *[]FilterCondition `json:"should,omitempty"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Checks Individual dependency health checks. New checks may appear
	// in future versions without a schema change.
	Checks map[string]HealthResponseChecks `json:"checks"`

	// Status Aggregate health status:
	// - ok: all checks pass
	// - degraded: non-critical check failed (e.g., embedding cache)
	// - error: critical check failed (e.g., valkey connection)
	Status HealthResponseStatus `json:"status"`

	// Version Service version (semver)
	Version *string `json:"version,omitempty"`
}

// HealthResponseChecks defines model for HealthResponse.Checks.
type HealthResponseChecks string

// HealthResponseStatus Aggregate health status:
// - ok: all checks pass
// - degraded: non-critical check failed (e.g., embedding cache)
// - error: critical check failed (e.g., valkey connection)
type HealthResponseStatus string

// PatchDocumentRequest Partial update with merge semantics. All fields are optional —
// only provided fields are updated. Set a tag/numeric value to `null`
// to remove it. Empty nested objects (`{"tags": {}}`) are no-ops:
// no error, no changes applied.
type PatchDocumentRequest struct {
	// Content New content text. If provided, triggers re-vectorization.
	// If omitted, existing content and vector are preserved.
	Content *string `json:"content,omitempty"`

	// Numerics Numerics to merge. Existing numerics not mentioned here are preserved.
	// Set a value to `null` to remove the numeric.
	Numerics *map[string]*float32 `json:"numerics,omitempty"`

	// Tags Tags to merge. Existing tags not mentioned here are preserved.
	// Set a value to `null` to remove the tag.
	Tags *map[string]*string `json:"tags,omitempty"`
}

// RangeFilter Numeric range filter. At least one boundary must be specified.
// Multiple boundaries are combined with AND. Do not mix `gt` with
// `gte` or `lt` with `lte` — returns 400 if both provided for
// the same direction.
type RangeFilter struct {
	// Gt Greater than
	Gt *float32 `json:"gt,omitempty"`

	// Gte Greater than or equal
	Gte *float32 `json:"gte,omitempty"`

	// Lt Less than
	Lt *float32 `json:"lt,omitempty"`

	// Lte Less than or equal
	Lte *float32 `json:"lte,omitempty"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	// Filters Flat filter with `must`, `should`, `must_not` semantics.
	// One level only — no recursive nesting.
	//
	// - **must**: all conditions must match (AND).
	// - **should**: at least one condition must match (OR).
	// - **must_not**: none of the conditions may match (NOT).
	//
	// Each condition targets a field by `key` and uses either `match`
	// (exact value, for tag fields) or `range` (for numeric fields).
	//
	// Equivalent boolean query semantics:
	// ```
	// language=python AND NOT archived=true AND (repo=vecdex OR repo=redcat)
	// ```
	//
	// An empty filter (`{}`) or a filter with all empty arrays is a no-op —
	// no filtering is applied, all candidates are returned.
	//
	// **Error handling:** Invalid filter expressions return 400 with
	// `code: validation_failed`. The `details` array contains per-field
	// errors, e.g. `{"field": "filters.must[0].key", "message": "unknown field"}`.
	// Unknown field names (not in collection schema) also return 400.
	Filters *FilterExpression `json:"filters,omitempty"`

	// IncludeVectors Include embedding vectors in the response. Vectors are returned
	// regardless of search mode — they exist in storage even when
	// keyword mode doesn't use them for ranking.
	IncludeVectors *bool `json:"include_vectors,omitempty"`

	// Limit Maximum results to return from the top_k window. If top_k=100
	// and limit=10, the server computes 100 nearest neighbors but
	// returns only the top 10. If limit > top_k, the server silently
	// caps to top_k (no error).
	Limit *int `json:"limit,omitempty"`

	// MinScore Minimum relevance score threshold. Results below this score are
	// excluded from the response. Applied as a post-filter on the server.
	// - In **semantic** mode: cosine similarity threshold.
	// - In **hybrid** mode: RRF score threshold (not cosine).
	// - In **keyword** mode: ignored (BM25 scores are not comparable
	//   across queries, so thresholding is unreliable).
	MinScore *float64 `json:"min_score,omitempty"`

	// Mode Search mode:
	// - **hybrid** (default): semantic + BM25 keyword search combined
	//   via Reciprocal Rank Fusion. Catches both exact identifiers and
	//   semantic meaning.
	// - **semantic**: pure vector KNN search.
	// - **keyword**: pure BM25 full-text search.
	// - **geo**: geographic proximity search. Query must be `"lat,lon"`
	//   string (e.g., `"40.7128,-74.0060"`). Only works on geo
	//   collections. Score is distance in meters.
	Mode *SearchRequestMode `json:"mode,omitempty"`

	// Query Search query text (auto-vectorized for semantic/hybrid modes).
	// Maximum 4096 characters. Queries exceeding this return 400.
	Query string `json:"query"`

	// TopK Number of nearest neighbors for KNN (the computation window).
	// The server computes this many candidates, then `limit` controls
	// how many are returned. Increasing `top_k` is more expensive.
	// In keyword mode, controls BM25 result window size.
	TopK *int `json:"top_k,omitempty"`
}

// SearchRequestMode Search mode:
//   - **hybrid** (default): semantic + BM25 keyword search combined
//     via Reciprocal Rank Fusion. Catches both exact identifiers and
//     semantic meaning.
//   - **semantic**: pure vector KNN search.
//   - **keyword**: pure BM25 full-text search.
//   - **geo**: geographic proximity search. Query must be `"lat,lon"`
//     string (e.g., `"40.7128,-74.0060"`). Only works on geo
//     collections. Score is distance in meters.
type SearchRequestMode string

// SearchResultItem defines model for SearchResultItem.
type SearchResultItem struct {
	Content  string              `json:"content"`
	Id       string              `json:"id"`
	Numerics *map[string]float32 `json:"numerics,omitempty"`

	// Score Relevance score. Meaning varies by mode:
	// - In **semantic** mode: cosine similarity (`1 - cosine_distance`), 0.0–1.0.
	// - In **keyword** mode: normalized BM25 score, 0.0–1.0.
	// - In **hybrid** mode: fused RRF score, 0.0–1.0. Not directly comparable
	//   to cosine similarity — represents relative ranking quality.
	// - In **geo** mode: great-circle distance in meters (Haversine).
	//   Lower values mean closer. NOT normalized to 0-1.
	// Note: `min_score` thresholds mean different things in each mode.
	Score float64            `json:"score"`
	Tags  *map[string]string `json:"tags,omitempty"`

	// Vector Embedding vector (only present when include_vectors=true)
	Vector *[]float32 `json:"vector,omitempty"`
}

// SearchResultListResponse defines model for SearchResultListResponse.
type SearchResultListResponse struct {
	Items []SearchResultItem `json:"items"`

	// Limit Requested limit
	Limit int `json:"limit"`

	// Total Number of candidates that passed min_score filtering within the
	// top_k window. May be greater than `limit` — in that case, increase
	// `limit` to see more results from the same KNN window. To get more
	// candidates overall, increase `top_k`.
	Total int `json:"total"`
}

// UpsertDocumentRequest defines model for UpsertDocumentRequest.
type UpsertDocumentRequest struct {
	// Content Document text content (will be auto-vectorized). Maximum size is
	// 160 KB (~41k tokens for the default embedding model). Requests
	// exceeding this limit return 400 with code `validation_failed`.
	Content string `json:"content"`

	// Numerics Numeric fields for filtering (must match collection schema)
	Numerics *map[string]float32 `json:"numerics,omitempty"`

	// Tags Tag fields for filtering (must match collection schema)
	Tags *map[string]string `json:"tags,omitempty"`
}

// UsageMetrics defines model for UsageMetrics.
type UsageMetrics struct {
	// CostMillidollars Estimated cost in millidollars (1 USD = 1,000 millidollars).
	// Absent if provider doesn't report cost. Use integer arithmetic
	// to avoid floating-point precision issues.
	CostMillidollars *int `json:"cost_millidollars,omitempty"`

	// EmbeddingRequests Number of embedding API calls in this period
	EmbeddingRequests int `json:"embedding_requests"`

	// Tokens Total embedding tokens consumed in this period
	Tokens int `json:"tokens"`
}

// UsageResponse defines model for UsageResponse.
type UsageResponse struct {
	Budget BudgetStatus `json:"budget"`

	// Collection Collection name if filtered, absent for global usage.
	Collection *string `json:"collection,omitempty"`

	// Period Aggregation period
	Period UsageResponsePeriod `json:"period"`

	// PeriodEndAt Period end (ISO 8601, UTC). Absent when period=total.
	PeriodEndAt *time.Time `json:"period_end_at,omitempty"`

	// PeriodStartAt Period start (ISO 8601, UTC). Absent when period=total.
	PeriodStartAt *time.Time   `json:"period_start_at,omitempty"`
	Usage         UsageMetrics `json:"usage"`
}

// UsageResponsePeriod Aggregation period
type UsageResponsePeriod string

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Field Field path that failed validation
	Field string `json:"field"`

	// Message Validation error message
	Message string `json:"message"`
}

// CollectionName defines model for CollectionName.
type CollectionName = string

// DocumentId defines model for DocumentId.
type DocumentId = string

// IfMatch defines model for IfMatch.
type IfMatch = int

// Limit defines model for Limit.
type Limit = int

// XRequestID defines model for XRequestID.
type XRequestID = string

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// CollectionNotFound defines model for CollectionNotFound.
type CollectionNotFound = ErrorResponse

// Conflict defines model for Conflict.
type Conflict = ErrorResponse

// DocumentNotFound defines model for DocumentNotFound.
type DocumentNotFound = ErrorResponse

// EmbeddingProviderError defines model for EmbeddingProviderError.
type EmbeddingProviderError = ErrorResponse

// EmbeddingQuotaExceeded defines model for EmbeddingQuotaExceeded.
type EmbeddingQuotaExceeded = ErrorResponse

// InternalError defines model for InternalError.
type InternalError = ErrorResponse

// NotImplemented defines model for NotImplemented.
type NotImplemented = ErrorResponse

// RateLimited defines model for RateLimited.
type RateLimited = ErrorResponse

// RevisionConflict defines model for RevisionConflict.
type RevisionConflict = ErrorResponse

// ListCollectionsParams defines parameters for ListCollections.
type ListCollectionsParams struct {
	// Cursor Opaque cursor from previous response. Omit for first page.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// CreateCollectionParams defines parameters for CreateCollection.
type CreateCollectionParams struct {
	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// DeleteCollectionParams defines parameters for DeleteCollection.
type DeleteCollectionParams struct {
	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// GetCollectionParams defines parameters for GetCollection.
type GetCollectionParams struct {
	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// ListDocumentsParams defines parameters for ListDocuments.
type ListDocumentsParams struct {
	// Cursor Opaque cursor from previous response. Omit for first page.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// BatchDeleteParams defines parameters for BatchDelete.
type BatchDeleteParams struct {
	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// BatchUpsertParams defines parameters for BatchUpsert.
type BatchUpsertParams struct {
	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// SearchDocumentsParams defines parameters for SearchDocuments.
type SearchDocumentsParams struct {
	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// DeleteDocumentParams defines parameters for DeleteDocument.
type DeleteDocumentParams struct {
	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// GetDocumentParams defines parameters for GetDocument.
type GetDocumentParams struct {
	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// PatchDocumentParams defines parameters for PatchDocument.
type PatchDocumentParams struct {
	// IfMatch Revision-based optimistic concurrency control. Pass the `revision`
	// value from a previous GET response. If the current revision doesn't
	// match, the server returns 409 with `code: revision_conflict`.
	// If omitted, the write proceeds unconditionally (no conflict check).
	IfMatch *IfMatch `json:"If-Match,omitempty"`

	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// UpsertDocumentParams defines parameters for UpsertDocument.
type UpsertDocumentParams struct {
	// IfMatch Revision-based optimistic concurrency control. Pass the `revision`
	// value from a previous GET response. If the current revision doesn't
	// match, the server returns 409 with `code: revision_conflict`.
	// If omitted, the write proceeds unconditionally (no conflict check).
	IfMatch *IfMatch `json:"If-Match,omitempty"`

	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// GetUsageParams defines parameters for GetUsage.
type GetUsageParams struct {
	// Collection Filter usage by collection name. If omitted, returns global usage.
	Collection *string `form:"collection,omitempty" json:"collection,omitempty"`

	// Period Aggregation period.
	Period *GetUsageParamsPeriod `form:"period,omitempty" json:"period,omitempty"`

	// XRequestID Client-provided request ID for tracing. If omitted, the server generates a UUID v4.
	XRequestID *XRequestID `json:"X-Request-ID,omitempty"`
}

// GetUsageParamsPeriod defines parameters for GetUsage.
type GetUsageParamsPeriod string

// CreateCollectionJSONRequestBody defines body for CreateCollection for application/json ContentType.
type CreateCollectionJSONRequestBody = CreateCollectionRequest

// BatchDeleteJSONRequestBody defines body for BatchDelete for application/json ContentType.
type BatchDeleteJSONRequestBody = BatchDeleteRequest

// BatchUpsertJSONRequestBody defines body for BatchUpsert for application/json ContentType.
type BatchUpsertJSONRequestBody = BatchUpsertRequest

// SearchDocumentsJSONRequestBody defines body for SearchDocuments for application/json ContentType.
type SearchDocumentsJSONRequestBody = SearchRequest

// PatchDocumentJSONRequestBody defines body for PatchDocument for application/json ContentType.
type PatchDocumentJSONRequestBody = PatchDocumentRequest

// UpsertDocumentJSONRequestBody defines body for UpsertDocument for application/json ContentType.
type UpsertDocumentJSONRequestBody = UpsertDocumentRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List collections
	// (GET /collections)
	ListCollections(w http.ResponseWriter, r *http.Request, params ListCollectionsParams)
	// Create collection
	// (POST /collections)
	CreateCollection(w http.ResponseWriter, r *http.Request, params CreateCollectionParams)
	// Delete collection
	// (DELETE /collections/{collection})
	DeleteCollection(w http.ResponseWriter, r *http.Request, collection CollectionName, params DeleteCollectionParams)
	// Get collection
	// (GET /collections/{collection})
	GetCollection(w http.ResponseWriter, r *http.Request, collection CollectionName, params GetCollectionParams)
	// List documents
	// (GET /collections/{collection}/documents)
	ListDocuments(w http.ResponseWriter, r *http.Request, collection CollectionName, params ListDocumentsParams)
	// Batch delete documents
	// (POST /collections/{collection}/documents/batch-delete)
	BatchDelete(w http.ResponseWriter, r *http.Request, collection CollectionName, params BatchDeleteParams)
	// Batch upsert documents
	// (POST /collections/{collection}/documents/batch-upsert)
	BatchUpsert(w http.ResponseWriter, r *http.Request, collection CollectionName, params BatchUpsertParams)
	// Search documents
	// (POST /collections/{collection}/documents/search)
	SearchDocuments(w http.ResponseWriter, r *http.Request, collection CollectionName, params SearchDocumentsParams)
	// Delete document
	// (DELETE /collections/{collection}/documents/{id})
	DeleteDocument(w http.ResponseWriter, r *http.Request, collection CollectionName, id DocumentId, params DeleteDocumentParams)
	// Get document
	// (GET /collections/{collection}/documents/{id})
	GetDocument(w http.ResponseWriter, r *http.Request, collection CollectionName, id DocumentId, params GetDocumentParams)
	// Partial update document
	// (PATCH /collections/{collection}/documents/{id})
	PatchDocument(w http.ResponseWriter, r *http.Request, collection CollectionName, id DocumentId, params PatchDocumentParams)
	// Upsert document
	// (PUT /collections/{collection}/documents/{id})
	UpsertDocument(w http.ResponseWriter, r *http.Request, collection CollectionName, id DocumentId, params UpsertDocumentParams)
	// Health check
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// Prometheus metrics
	// (GET /metrics)
	Metrics(w http.ResponseWriter, r *http.Request)
	// Get embedding usage and budget
	// (GET /usage)
	GetUsage(w http.ResponseWriter, r *http.Request, params GetUsageParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List collections
// (GET /collections)
func (_ Unimplemented) ListCollections(w http.ResponseWriter, r *http.Request, params ListCollectionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create collection
// (POST /collections)
func (_ Unimplemented) CreateCollection(w http.ResponseWriter, r *http.Request, params CreateCollectionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete collection
// (DELETE /collections/{collection})
func (_ Unimplemented) DeleteCollection(w http.ResponseWriter, r *http.Request, collection CollectionName, params DeleteCollectionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get collection
// (GET /collections/{collection})
func (_ Unimplemented) GetCollection(w http.ResponseWriter, r *http.Request, collection CollectionName, params GetCollectionParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List documents
// (GET /collections/{collection}/documents)
func (_ Unimplemented) ListDocuments(w http.ResponseWriter, r *http.Request, collection CollectionName, params ListDocumentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Batch delete documents
// (POST /collections/{collection}/documents/batch-delete)
func (_ Unimplemented) BatchDelete(w http.ResponseWriter, r *http.Request, collection CollectionName, params BatchDeleteParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Batch upsert documents
// (POST /collections/{collection}/documents/batch-upsert)
func (_ Unimplemented) BatchUpsert(w http.ResponseWriter, r *http.Request, collection CollectionName, params BatchUpsertParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Search documents
// (POST /collections/{collection}/documents/search)
func (_ Unimplemented) SearchDocuments(w http.ResponseWriter, r *http.Request, collection CollectionName, params SearchDocumentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete document
// (DELETE /collections/{collection}/documents/{id})
func (_ Unimplemented) DeleteDocument(w http.ResponseWriter, r *http.Request, collection CollectionName, id DocumentId, params DeleteDocumentParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get document
// (GET /collections/{collection}/documents/{id})
func (_ Unimplemented) GetDocument(w http.ResponseWriter, r *http.Request, collection CollectionName, id DocumentId, params GetDocumentParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Partial update document
// (PATCH /collections/{collection}/documents/{id})
func (_ Unimplemented) PatchDocument(w http.ResponseWriter, r *http.Request, collection CollectionName, id DocumentId, params PatchDocumentParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upsert document
// (PUT /collections/{collection}/documents/{id})
func (_ Unimplemented) UpsertDocument(w http.ResponseWriter, r *http.Request, collection CollectionName, id DocumentId, params UpsertDocumentParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Prometheus metrics
// (GET /metrics)
func (_ Unimplemented) Metrics(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get embedding usage and budget
// (GET /usage)
func (_ Unimplemented) GetUsage(w http.ResponseWriter, r *http.Request, params GetUsageParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListCollections operation middleware
func (siw *ServerInterfaceWrapper) ListCollections(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCollectionsParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListCollections(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateCollection operation middleware
func (siw *ServerInterfaceWrapper) CreateCollection(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateCollectionParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCollection(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteCollection operation middleware
func (siw *ServerInterfaceWrapper) DeleteCollection(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteCollectionParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCollection(w, r, collection, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCollection operation middleware
func (siw *ServerInterfaceWrapper) GetCollection(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCollectionParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCollection(w, r, collection, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListDocuments operation middleware
func (siw *ServerInterfaceWrapper) ListDocuments(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDocumentsParams

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDocuments(w, r, collection, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// BatchDelete operation middleware
func (siw *ServerInterfaceWrapper) BatchDelete(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params BatchDeleteParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BatchDelete(w, r, collection, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// BatchUpsert operation middleware
func (siw *ServerInterfaceWrapper) BatchUpsert(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params BatchUpsertParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BatchUpsert(w, r, collection, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SearchDocuments operation middleware
func (siw *ServerInterfaceWrapper) SearchDocuments(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchDocumentsParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SearchDocuments(w, r, collection, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocument operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDocumentParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocument(w, r, collection, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocument operation middleware
func (siw *ServerInterfaceWrapper) GetDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDocumentParams

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocument(w, r, collection, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchDocument operation middleware
func (siw *ServerInterfaceWrapper) PatchDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchDocumentParams

	headers := r.Header

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatch
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchDocument(w, r, collection, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpsertDocument operation middleware
func (siw *ServerInterfaceWrapper) UpsertDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "collection" -------------
	var collection CollectionName

	err = runtime.BindStyledParameterWithOptions("simple", "collection", chi.URLParam(r, "collection"), &collection, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	// ------------- Path parameter "id" -------------
	var id DocumentId

	err = runtime.BindStyledParameterWithOptions("simple", "id", chi.URLParam(r, "id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpsertDocumentParams

	headers := r.Header

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatch
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpsertDocument(w, r, collection, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Metrics operation middleware
func (siw *ServerInterfaceWrapper) Metrics(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Metrics(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetUsage operation middleware
func (siw *ServerInterfaceWrapper) GetUsage(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsageParams

	// ------------- Optional query parameter "collection" -------------

	err = runtime.BindQueryParameter("form", true, false, "collection", r.URL.Query(), &params.Collection)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "collection", Err: err})
		return
	}

	// ------------- Optional query parameter "period" -------------

	err = runtime.BindQueryParameter("form", true, false, "period", r.URL.Query(), &params.Period)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "period", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-ID", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-ID", Err: err})
			return
		}

		params.XRequestID = &XRequestID

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsage(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections", wrapper.ListCollections)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/collections", wrapper.CreateCollection)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/collections/{collection}", wrapper.DeleteCollection)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections/{collection}", wrapper.GetCollection)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections/{collection}/documents", wrapper.ListDocuments)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/collections/{collection}/documents/batch-delete", wrapper.BatchDelete)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/collections/{collection}/documents/batch-upsert", wrapper.BatchUpsert)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/collections/{collection}/documents/search", wrapper.SearchDocuments)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/collections/{collection}/documents/{id}", wrapper.DeleteDocument)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/collections/{collection}/documents/{id}", wrapper.GetDocument)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/collections/{collection}/documents/{id}", wrapper.PatchDocument)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/collections/{collection}/documents/{id}", wrapper.UpsertDocument)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/metrics", wrapper.Metrics)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/usage", wrapper.GetUsage)
	})

	return r
}
